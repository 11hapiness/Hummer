## 导出组件指南（Hummer API）
在现有 iOS/Android 的Hummer SDK 中，导出组件的JS对象（接口）是由原生注入的。  
但是在鸿蒙上，引入了 Hummer API（后续iOS/Android也会逐步迁移使用 Hummer API）   
详见[Hummer API 设计文档](https://cooper.didichuxing.com/knowledge/2199483284891/2201653692995)

Hummer API 源码地址：
https://github.com/didi/Hummer/tree/hummer_2.0/api

可以把  Hummer  API 理解为：Hummer front 的实体。  
因此在鸿蒙下实现导出原生组件，分为一般分为三步：  
1. 在前端工程中开发 Hummer API，即：js组件
2. 在鸿蒙项目中实现 原生组件
3. 在鸿蒙项目中注册 原生组件，和 JS 组件进行绑定

在开始前，需要把 Hummer API 作为项目依赖
### 创建一个Hummer 前端项目

> 开发Hummer API 推荐使用ts开发。

添加依赖仓库

```javascript

//在package.json 文件中添加以来组件库

  "dependencies": {
    "@didi/hummer-api": "^0.0.1",
  },

```
### 导出非视图组件
下面开始导出非视图组件
#### 开发 JS 组件（Hummer API）
非视图组件即没有UI的功能组件只提供方法调用能力。需要继承HummerComponent
```javascript
// 导入 Hummer API
import { HummerComponent } from "@didi/hummer-api"

//组件名称：MyTest
export class MyTest extends HummerComponent {

    public constructor(props: any = {}) {
        super("MyTest", props);
    }

    public set(key: string, value: Record<string, any>, cb?: Function) {
        this.call("set", key, value, cb);
    }

    public get(key: string, cb?: Function): any {
        return this.call("get", key, cb);
    }

    public remove(key: string, cb?: Function) {
        this.call("remove", key, cb);
    }

    public removeAll(cb?: Function) {
        this.call("removeAll", cb);
    }

    public exist(key: string, cb?: Function) {
        return this.call("exist", key, cb);
    }
}
```
#### 在鸿蒙项目中实现 原生组件
鸿蒙非UI原生组件需要继承 HMComponent，实现可以用 ts，也可以使用ets。选择条件如下：  
1. ts 的好处更灵活，可以实现很多ets禁用的能力，但是无法调用系统ets接口，
2. ets 语法校验严格，可以使用系统 ets/ts 能力
```javascript
//组件名称：MyTest
export class MyTest extends HMComponent {
    // 注意，所有原生组件，都不应该直接被其他鸿蒙组件直接调用。（参考现有ios/android 的导出组件：不能被其他oc/java组件直接调用）
    private set(key: string, value: Record<string, any>, cb?: Function) {
    // do something
    }

    private get(key: string, cb?: Function): any {
    // do something
    }

    private remove(key: string, cb?: Function) {
    // do something
    }

    private removeAll(cb?: Function) {
    // do something
    }

    private exist(key: string, cb?: Function) {
    // do something
    }
}
```
在原生组件实现好之后，下面需要将原生组件和js组件进行绑定。
#### 注册原生组件
在创建 HMEntrance 的 config 参数中，传入组件映射表即可
```javascript
build() {
    NavDestination() {
        HMEntrance({
            controller: this.entranceController,
            pageData:this.pageData,
            contentProvider:this.contentProvider,
            config: {
                nameSpace: DRIVER_RED_NAME_SPACE,
                componentRegistry: {'MyTest':MyTest},//注册组件：{'js组件名':鸿蒙原生组件类}
                navigatorAdapter: this.dNavigationParam ? hummerNavigatorAdaptor : undefined//只有通过 dNavigation 打开的页面，才使用适配器
            },
            customComponentBuilder: this.customComponentBuilder
        })
            .width('100%')
            .height('100%')
    }
}
```

### 端上直接注册方法迁移方案

例子：

```java
JSContext.registerJSFunction(jsPage, "notifyCaller", new ICallback() {});

```

因为Hummer2是多线程架构不再支持直接方法注册，仅支持组件接口。请参考上面非视图组件导出，将注册接口“notifyCaller”转换成标准组件接口。


### 端上直接调用Hummer接口迁移方案

例子：

```java
jsValue.set("OderID","20001");
jsValue.callFunction("updateUserInfo",userInfo);

```


因为Hummer2是多线程架构不再支持直接方法调用或者属性修改，请参考上面非视图组件导出。

导出一个新组件，使用组件Hummer API  addEventListener("OderID_setter",(event)=>{}),结合：端侧 dispatchEvent（"OderID_setter",event）.来修改订单ID或者修改用户信息。


```javascript

// 导入 Hummer API
import { HummerComponent } from "@didi/hummer-api"

//组件名称：MyBridger
export class MyBridger extends HummerComponent {

    public constructor(props: any = {}) {
        super("MyBridger", props);
        
        this.addEventListener("OderID_setter",(event:any)=>{
           //TODO 
           this.oder.OderID = event.OderID;
        });
        
        this.addEventListener("updateUserInfo",(event:any)=>{
            this.updateUserInfo(event.userInfo);
        });
    }
    
    public updateUserInfo(userInfo:any){
        //TODO
    }

}

```

如果是跨页面场景。也可使用NotifyCenter组件发送全局消息来修改订单ID/修改用户信息。


下面开始介绍导出视图组件
### 导出视图组件
导出视图组件必须继承HummerElement，编写需要的扩展能力
示例代码如下：
```javascript
import { HummerElement } from "@didi/hummer-api"
import { FlexStyle } from "@didi/hummer-apit"

//扩展视图样式
interface MyButtonStyle extends FlexStyle {
    mycolor?: string
    myfontFamily?: string
    myfontSize?: number|string
    mytextAlign?:	string
}


export class MyButton extends HummerElement {

    /**
     * 构造方法
     
     * @param id
     * @param name 
     * @param props 
     */
    public constructor(id: string = "", name: string = "", props: any = {}) {
        super("MyButton", name, { ...props, viewId: id });
    }
    //扩展样式属性：有代理时通过代理处理
    public set style(value: MyButtonStyle | Record<string, any>) {
        this.setStyle(value, false);
    }
    //扩展组件属性
    /**
     * 按钮文案
     */
    get text() {
        return this._getAttribute("text")
    }

    set text(value: string) {
        this._setAttribute("text", value);
    }

    /**
     * 按压状态下的样式
     */
    get pressed() {
        return this._getAttribute("pressed")
    }

    set pressed(value: object) {
        this._setAttribute("pressed", value);
    }
    /**
     * 禁用状态下的样式
     */
    override get disabled() {
        return this._getAttribute("disabled")
    }

    override set disabled(value:  Boolean | Record<string, any>) {
        if(typeof value === "boolean"){
            super.disabled = value
        }else{
            this._setAttribute("disabled", value);
        }
    }
     /**
     * 
     * @param key 
     * @param value 
     * @returns 
     * 
     * 1、所有组件支持的属性都需要写 get set方法 兼容旧版本api使用。
     * 2、对有额外处理的需要重新setAttribute方法，对tenon调用接口做补充，增加额外处理
     */
      public setAttribute(key: string, value: any): void {
        switch (key) {
            case 'disabled':
                if(typeof value === "boolean"){
                    super.disabled = value
                }else{
                    this._setAttribute("disabled", value);
                }
                return;

        }
        this._setAttribute(key, value);
    }
    
    //扩展组件方法
    
    public showMyText(myText:string) {
        return this.call("showMyText",myText)
    }

}
```
### 在鸿蒙项目中实现 原生组件
Arkts 使用声明式开发，无法像 iOS/Android 那样根据js调用的方法/属性，直接修改视图的状态。  
因此需要视图模型来记录JS调用的方法/属性，然后理由arkts的数据绑定，更新到视图上。  

HMNode 提供了基础的样式/属性更新事件，方法调用事件的能力，当 js 调用原生方法时，会通过 HMNode 转发到 ets 组件内。  
开发者通常不需要自定义数据模型，仅当 JS 组件调用原生方法时，ets组件还未创建的情况下，需要继承 HMNode，参考[HMViewNode](https://git.xiaojukeji.com/OrangeLabs/Harmony/ohhummer/blob/main/hummer/src/main/ets/Components/ets/View/ViewNode.ts)  

下面开始实现：
#### 创建 ets 组件
首先创建属性包装器，如果该组件的样式，属性都为通用样式，则使用 <IHummerStyle, IHummerBaseAttributes> 即可。  
MyButton 中 pressed 为特有属性，因此需要单独声明。代码如下：
```javascript
//ts 文件
export interface IMyButtonTextAttributes extends IHummerBaseAttributes {
    pressed?:boolean
    text?:string
}
//ts 文件
export class MyButtonPropsWrapper extends ViewBasePropsWrapper<IHummerStyle, IMyButtonTextAttributes> {

    constructor(public readonly node:HMNode) {
        super(node, node.style, node.attributes);
    }
    // 组件默认表现
    get pressed(){
        if(isUndefined(this.attributes.pressed)) {return false}
        return this.attributes.pressed;
    }
    get text(){
        if(isUndefined(this.attributes.text)) {return '默认文案'}
        return this.attributes.text
    }
}
```
下面开始创建 ets 组件
```javascript
@Component
export default struct MyButton {
    
  builderContext!:ComponentBuilderContext // 鸿蒙自定义组件构建参数
  private hmContext!:HMContext;// Hummer 上下文
  private node!:HMNode;//当前视图组件的数据模型
  @State private props:MyButtonPropsWrapper | undefined = undefined; //对 HMNode 的二次包装，实现ets组件和 HMNode 的双向绑定
  @State private children: HMNode[] = [] // 自节点，如果有
  aboutToAppear(): void {

    this.hmContext = this.builderContext.hmContext;
    this.node = this.builderContext.node;

    this.props = new MyButtonPropsWrapper(this.node);
    this.props.bindPropsUpdate()//必须调用此方法，才能实现 props 的样式/属性变化，ets组件自动更新
        
     // 注册方法调用
    this.node.registerNativeFunc("showMyText", (text:string) => {
        //do something
    })
  }


// hdc
  aboutToDisappear(): void {
    this.props?.dispose();//销毁方法，必须调用，否则会导致内存泄漏，或释放慢
  }

  build(){
        Button(this.props.text){
            
        }.attributeModifier(commonStyleModifier.setNode(this.node, this.props?.style))//填充通用样式

    }
}
```
#### 注册组件
在创建 HMEntrance 的 customComponentBuilder 参数中，自定义组件 builder 即可。  
注意如果需要自定义了数据模型，则需要创建继承 HMNode 的子类，如 MyButtonNode，然后注册到 config 中。
```javascript
@Builder
export function componentFactoryBuilder(ctx: ComponentBuilderContext) {
    if (ctx.tag === 'MyButton') {
        MyButton({ builderContext: ctx })
    }
}

build() {
    NavDestination() {
        HMEntrance({
            controller: this.entranceController,
            pageData:this.pageData,
            contentProvider:this.contentProvider,
            config: {
                nameSpace: DRIVER_RED_NAME_SPACE,
                componentRegistry: {'MyButton':MyButtonNode},//注册组件：{'js组件名':鸿蒙原生组件类}
                navigatorAdapter: this.dNavigationParam ? hummerNavigatorAdaptor : undefined//只有通过 dNavigation 打开的页面，才使用适配器
            },
            customComponentBuilder: wrapBuilder(componentFactoryBuilder) //传入自定义 ets 组件工厂
        })
            .width('100%')
            .height('100%')
    }
}
```
### 导出静态组件
Hummer新框架不支持静态组件，需要静态方式使用组件时，仅支持在API中将组件能力封装为静态。并且单例必须挂载到__Hummer__ 节点上（保证页面级独立，在鸿蒙系统中仅一个上下文）。
示例代码如下：
```javascript
import { HummerComponent } from "@didi/hummer-api"

const HUMMER = __Hummer__;

export class MyTestStatic extends HummerComponent {

    public constructor(props: any = {}) {
        super("MyTestStatic", props);
    }

    static get instance(): MyTestStatic {
    if (!HUMMER.__MyTestStatic__) {
            HUMMER.__MyTestStatic__ = new MyTestStatic();
        }
        return HUMMER.__MyTestStatic__
    }

    // 可以通过单例组件的方式来实现静态组件接口

    /**
     * testCall
     *
     * @param key 名称
     */
    static testCall(key: string, cb?: Function) {
        MyTestStatic.instance.testCall(key, cb);
    }

    /**
    *  removeAll
    */
    public static removeAll(cb?: Function) {
        MyTestStatic.instance.removeAll(cb);
    }

    //组件的方法必须都是非静态

    protected testCall(key: string, cb?: Function): any {
        return this.call("testCall", key, cb);
    }

    protected removeAll(cb?: Function) {
        this.call("removeAll", cb);
    }

}
```
接下来创建鸿蒙原生组件
#### 在鸿蒙项目中实现 原生组件
鸿蒙非UI原生组件需要继承 HMComponent。
```javascript
//组件名称：MyTest
export class MyTestStatic extends HMComponent {
    // 注意，所有原生组件，都不应该直接被其他鸿蒙组件直接调用。（参考现有ios/android 的导出组件：不能被其他oc/java组件直接调用）
    // 同时原生组件 不能声明 static 方法，因为 鸿蒙为单运行时环境，static 会导致内存无法回收
    // MyTestStatic 在一个hummer 上下文的单例，由 Hummer API 保证
    private testCall(key: string, cb?: Function) {
       // do something
    }

    private removeAll(cb?: Function) {
    // do something
    }
}
```
在原生组件实现好之后，下面需要将原生组件和js组件进行绑定。
#### 注册原生组件
在创建 HMEntrance 的 config 参数中，传入组件映射表即可
```javascript
build() {
    NavDestination() {
        HMEntrance({
            controller: this.entranceController,
            pageData:this.pageData,
            contentProvider:this.contentProvider,
            config: {
                nameSpace: DRIVER_RED_NAME_SPACE,
                componentRegistry: {'MyTestStatic':MyTestStatic},//注册组件：{'js组件名':鸿蒙原生组件类}
                navigatorAdapter: this.dNavigationParam ? hummerNavigatorAdaptor : undefined//只有通过 dNavigation 打开的页面，才使用适配器
            },
            customComponentBuilder: this.customComponentBuilder
        })
            .width('100%')
            .height('100%')
    }
}
```
### 导出组件发布

> 导出组件不一定需要独立发布，如果是业务组件可以与业务代码一起以Hummer产物的方式发布运行。或者将导出组件单独发布，业务开发以组件库形式使用。
